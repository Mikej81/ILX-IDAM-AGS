// $F5Copyright_C:
// Copyright (C) F5 Networks, Inc. 2014
'use strict';

module.exports = Demuxer;
// exports.DemuxStream = DemuxStream;

var stream = require('stream');
var util = require('util');

function DemuxStream(channel) {
  stream.Duplex.call(this);
  this.read = stream.Duplex.prototype.read;
  this.end = stream.Duplex.prototype.end;
  this.demux = channel;
}
util.inherits(DemuxStream, stream.Duplex);

DemuxStream.prototype._read = function(n) {
};

DemuxStream.prototype._write = function(chunk, encoding, cb) {
    var buf = new Buffer(chunk.length + 4);
    buf.writeUInt32BE(chunk.length);
    chunk.copy(buf, 4);
    this.demux.handle.write(buf);
    cb();
};

DemuxStream.prototype.destroy = function() {
};

function demuxPipe(src) {
  this.handle = src;
}

function demuxUnpipe() {
  this.handle = null;
  if (this.message) {
    var e = new Error('Incomplete Message');
    this.message.emit('error', e);
  }
  if (this.buflen) {
    var e = new Error('Incomplete Header');
    this.emit('error', e);
  }
}

function Demuxer(msgListener) {
  if (!(this instanceof Demuxer)) {
    return new Demuxer();
  }
  if (msgListener) {
    this.addListener('message', msgListener);
  }
  this.addListener('unpipe', demuxUnpipe);
  this.addListener('pipe', demuxPipe);
  stream.Transform.call(this);

  this.minlen = 4;
  this.buflen = 0;
  this.buffer = [];
  this.count = 0;
  this.decode = startTransfer;
  this.message = null;
  this.handle = null;
}
util.inherits(Demuxer, stream.Transform);

function countedTransfer(chunk) {
  var len = chunk.length;
  var buffer = null;
  if (len > this.count) {
    buffer = chunk.slice(this.count);
    chunk = chunk.slice(0, this.count);
    this.count = 0;
  } else {
    this.count -= len;
  }
  this.message.push(chunk);
  if (this.count === 0) {
    this.message.push(null);
    this.message = null;
    this.decode = startTransfer;
  }
  return buffer;
}

function startTransfer(chunk) {
  var len = chunk.length;
  var used, header;
  if (len + this.buflen < this.minlen) {
    this.buffer.push(chunk);
    this.buflen += len;
    return null;
  }
  if (this.buflen !== 0) {
    used = this.minlen - this.buflen;
    this.buffer.push(chunk.slice(0, used));
    header = Buffer.concat(this.buffer);
    this.buflen = 0;
    this.buffer = [];
  } else {
    used = this.minlen;
    header = chunk;
  }
  this.count = header.readUInt32BE(0);
  this.decode = countedTransfer;
  this.message = new DemuxStream(this);
  this.emit('message', this.message);
  return chunk.slice(used);
}

Demuxer.prototype._transform = function(chunk, encoding, cb) {
  do {
    chunk = this.decode(chunk);
  } while (chunk !== null);
  cb();
};
