// $F5Copyright_C:
// Copyright (C) F5 Networks, Inc. 2014
'use strict';

module.exports.ILXServer = ILXServer;
module.exports.createILXServer = createILXServer;

var EventEmitter = require('events').EventEmitter;
var Demuxer = require('./demux').Demuxer;
var timers = require('timers');
var util = require('util');
var net = require('net');
var bl = require('bl');
var stream = require('stream');

/*
 * Initial request, or a callout response.
 */
function ILXIncomingMsg() {
  this.msg = null;
}

ILXIncomingMsg.prototype.params = function() {
  return this.msg.params;
};

ILXIncomingMsg.prototype.method = function() {
  return this.msg.method;
};

function ILXOutgoingMsg() {
  this.id = null;
  this.seq = null;
  this.handle = null;
  this.server = null;
}

ILXOutgoingMsg.prototype.error = function() {
  var msg = this;
  if (!msg.handle) {
    throw new Error('Internal error: no handle');
  }
  if (msg.id === undefined) {
    throw new Error('Cannot return error to notification');
  }
  var args = Array.prototype.slice.call(arguments);
  var e = args.length == 1 ? args[0] : args;
  var json = {
    'id' : msg.id,
    'error' : { 'code' : 30, 'message' : e },
  };
  var reply = JSON.stringify(json);
  msg.handle.end(reply);
  msg.handle = null;
};

ILXOutgoingMsg.prototype.reply = function() {
  var msg = this;
  if (!msg.handle) {
    throw new Error('Internal error: no handle');
  }
  if (msg.id === undefined) {
    throw new Error('Cannot reply to notification');
  }
  var args = Array.prototype.slice.call(arguments);
  var r = args.length == 1 ? args[0] : args;
  var json = {
    'id' : msg.id,
    'result' : r,
  };
  var reply = JSON.stringify(json);
  msg.handle.end(reply);
  msg.handle = null;
};

/*---------------------------------------------------------------------------*/

function ILXServer(table, opts) {
  if (!(this instanceof ILXServer)) {
    return new ILXServer(table);
  }
  net.Server.call(this, { allowHalfOpen: true });

  opts = opts || {};

  this.cb = table || {};
  this.callout = {};
  this.ismuxed = false;
  this.setDefaultMethod(opts.defaultMethod);

  this.addListener('connection', ilxListener);

  this.addListener('clientError', function(err, conn) {
    conn.destroy();
  });

  this.timeout = opts.timeout !== undefined ? opts.timeout * 1000 : 5 * 1000;
}
util.inherits(ILXServer, net.Server);

ILXServer.prototype.addMethod = function(method, cb) {
    this.cb[method] = cb;
};

ILXServer.prototype.removeMethod = function(method) {
    delete this.cb[method];
};

ILXServer.prototype.setDefaultMethod = function(callback) {
    this.defaultMethod = callback;
};

ILXServer.prototype.listen = function(port) {
    net.Server.prototype.listen.call(this, port || 530);
};

function createILXServer(table, opts) {
  return new ILXServer(table, opts);
}

function ilxListener(socket) {
  var server = this;

  if (server.timeout) {
    socket.setTimeout(server.timeout);
  }

  /*
   * note: socket timeout is a data idle timeout, not an absolute timeout.
   * so the server is vulnerable to slowloris type atttacks.
   */
  socket.on('timeout', function() {
    var serverTimeout = server.emit('timeout', socket);
    if (!serverTimeout)
      socket.destroy();
  });

  /* Forward socket error to server. */
  socket.on('error', function(e) {
    server.emit('clientError', e, this);
  });

  function newStream(stream) {
    stream.pipe(bl(function(err, d) {
      if (err) {
        return server.emit('clientError', err, stream);
      }
      var json;
      try {
        json = JSON.parse(d);
      } catch(err) {
        return server.emit('clientError', err, stream);
      }

      if (json.method !== undefined) {
        var req = new ILXIncomingMsg();
        req.msg = json;
        var userMethodArgs = [ req ];
        if (json.id === undefined) {
          // Cannot reply, so close socket immediately.
          socket.end();
        } else {
          var res = new ILXOutgoingMsg();
          res.id = json.id;
          res.handle = stream;
          res.server = server;
          userMethodArgs.push(res);
        }
        var userMethod = server.cb[json.method] || server.defaultMethod;
        if (!userMethod) {
          if (res != null) {
            res.error("method not found");
          }
          return;
        }
        userMethod.apply(server, userMethodArgs);
        return;
      }

      /* Not a method, check for result or error, along with id. */
      if (!(json.id in server.callout) ||
          ((typeof json.error === 'undefined') !=
           (typeof json.result === 'undefined'))) {
        return server.emit('clientError', "Incorrect JSON message", stream);
      }

      var callout = server.callout[json.id];
      delete server.callout[json.id];
      var reply = new ILXIncomingMsg();
      reply.json = json;
      callout.cb(reply);
    }));
  }

  if (server.ismuxed) {
    var demuxer = new Demuxer(newStream);
    demuxer.on('error', function(e) {
      socket.unpipe();
      socket.emit('clientError', e, this);
    });
    socket.pipe(demuxer);
  } else {
    newStream(socket);
  }
}
